"""
This module uses the Monte Carlo Simulation to find the best weights of portfolio.
The evaluation of portfolios based on Modern Portfolio Theory and Sharpe Ratio.
"""
import datetime
import time
import concurrent.futures
from multiprocessing import Pool
# API to get stocks data from yahoo.
import numpy as np
import matplotlib.pyplot as plt

import pandas as pd
import pandas_datareader.data as web
from pandas_datareader._utils import RemoteDataError


class Portfolio:
    """
    This class realizes the main function of our program.
    """

    def __init__(self, stock_list, start_date: str, end_date: str, index_a: float, processes: int, user):
        """
        :param stock_list: A list of stocks given by user.
        :param start_date: The start date of stock data.(Format: '2016-12-01')
        :param end_date: The end date of stock data.(Format:'2017-12-01')
        :param index_a: Risk Aversion Coefficient, different from users,range from 0~14,
        you can change it and test.
        :param processes: Amount of processes.
        """
        self.stock_set = stock_list
        self.start_date = Portfolio.time_convertor(start_date)
        self.end_date = Portfolio.time_convertor(end_date)
        self.index_a = index_a
        self.processes = processes
        self.trading_days = 0
        self.returns = False
        self.user = user

    @staticmethod
    def request(arr: list):
        """
        get a stock's data from yahoo.
        :param arr: Array that stores the information of stocks we acquire..
        :return: return the daily earnings of stocks.
        """

        req = None
        num = 0
        while req is None:
            try:
                stock_data = web.DataReader(
                    arr[2], 'yahoo', start=arr[0], end=arr[1])
            except RemoteDataError:
                # It automatically
                print('Data request failed, trying again..')
                time.sleep(3)
                num += 1
                if num == 5:
                    print('The request failed for 5 times, Please check your input.')
                    break
            else:
                if arr[3].trading_days == 0:
                    arr[3].trading_days = len(stock_data.index)
                # earning generated by MPT(reference 1)
                # get daily earnings
                earnings = np.log(
                    stock_data['Close'] / stock_data['Close'].shift(1))
                return earnings

    @staticmethod
    def time_convertor(date: str):
        """
        Transfer string type date to datetime date.
        :param date: string date( format '2017-8-10')
        :return: datetime date.
        >>> Portfolio.time_convertor('2016-7-22')
        datetime.datetime(2016, 7, 22, 0, 0)
        >>> Portfolio.time_convertor(2016)
        Traceback (most recent call last):
        ...
        TypeError: strptime() argument 1 must be str, not int
        """
        date = datetime.datetime.strptime(
            date, '%Y-%m-%d').replace(hour=0, minute=0, second=0, microsecond=0)
        return date

    def get_data(self):
        """
        Multi processing request() and convert daily earnings to a dataframe.
        :param self:
        :return: return as a dataframe containing all earnings.
        """

        returns = False
        temp = []
        for i in self.stock_set:
            temp.append([self.start_date, self.end_date, i, self])
            # multiple processing
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.processes) as executor:
            re_ar = executor.map(self.request, temp)
        for i in re_ar:
            if returns is False:
                returns = i
            else:
                # convert list to dataframe
                returns = pd.concat([returns, i], join='outer', axis=1)
        self.returns = returns
        return returns

    def point(self, _):
        """
        get a random set of weights and calculate investor utility
        :param self:
        :return: val: Invertor utility, weight: a list of weights,
        temp_re: expect return, temp_va: expect risk
        """
        # simulate random weights
        weights = np.random.random(len(self.stock_set))
        # random weight
        weights /= np.sum(weights)
        # except return generated by MPT
        temp_re = np.sum(self.returns.mean() * self.trading_days * weights)
        # except variance(risk) generated by MPT
        temp_va = np.sqrt(
            np.dot(
                # Converted to annual revenue
                weights.T, np.dot(self.returns.cov() * self.trading_days, weights)))
        # Investor utility
        val = temp_re - self.index_a * temp_va * temp_va
        return val, weights, temp_re, temp_va

    def plo(self, tag: int, times: int):
        """
        This function arranges particular stocks in different weights with n times.(n Points)

        :param self:
        :param tag: draw or not
        :param times: total points we are going to draw.
        :return:  max_we: The particular set of  weights, which can create most value.
                  max_value: The max value returned by a particular stocks with max_we.
        """
        port_returns = []
        port_variance = []
        max_val = -100
        # multiple processing
        with Pool(processes=self.processes) as pool:
            re_ar = pool.map(self.point, range(times))
        # find which portfolio's utility is the highest
        for i in re_ar:
            if i[0] > max_val:
                max_val = i[0]
                max_we = i[1]
                max_re = i[2]
                max_va = i[3]
            port_returns.append(i[2])
            port_variance.append(i[3])
        # draw a plot or not
        if tag == 1:
            # using color add utility as a third dimension
            plt.clf()
            plt.scatter(port_variance, port_returns, c=port_returns - self.index_a *
                        np.array(port_variance) * np.array(port_variance), marker='o')
            plt.grid(True)
            plt.plot(max_va, max_re, 'r*', markersize=10.0)
            plt.xlabel('variance')  # variance
            plt.ylabel('returns')  # returns
            plt.colorbar(label='Investor utility')  # Investor utility
            plt.savefig('media/' + str(self.user) + '.png')
        # return the maximum weight and maximum value.
        return max_we, max_val

    def print(self, max_we: list):
        """
        print results
        :param self:
        :param max_we: Best weights
        """
        for i, weight in enumerate(max_we):
            print(self.stock_set[i] + ":  " + str(weight * 100) + "%")

    def compute(self):
        """
        Concatenate the function and run the program.

        """
        self.get_data()
        max_we = self.plo(0, 3000)[0]
        self.print(max_we)


if __name__ == '__main__':
    # setting the initial value
    ALL_STOCK = ['AMD', 'AAPL', 'F', 'T', 'CTL']
    START = '2018-01-01'
    END = '2019-01-01'
    RISK_A = 5.5
    PROCESSOR = 4
    BASIC_TIMES = 20
    STOCK_NUM = 3
    # generate the final portfolio
    FIN_PORT = Portfolio(ALL_STOCK, START, END, RISK_A, PROCESSOR)
    FIN_PORT.get_data()
    RESULT = FIN_PORT.plo(1, 4000)[0]
    FIN_PORT.print(RESULT)
